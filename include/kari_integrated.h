// Generated by gencpp from file kari_estimator/kari_integrated.msg
// DO NOT EDIT!

#ifndef KARI_ESTIMATOR_MESSAGE_KARI_INTEGRATED_H
#define KARI_ESTIMATOR_MESSAGE_KARI_INTEGRATED_H

#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

namespace kari_estimator
{
  template <class ContainerAllocator>
  struct kari_integrated_
  {
    typedef kari_integrated_<ContainerAllocator> Type;

    kari_integrated_()
        : timestamp(0), t_sec(0.0), delt_sec(0.0), delx_rps(0.0), dely_rps(0.0), qual(0.0), gx_rps(0.0), gy_rps(0.0), gz_rps(0.0), ax_mps2(0.0), ay_mps2(0.0), az_mps2(0.0), h_mtr(0.0), mx_gauss(0.0), my_gauss(0.0), mz_gauss(0.0), rsv0(0.0), rsv1(0.0), rsv2(0.0), rsv3(0.0)
    {
    }
    kari_integrated_(const ContainerAllocator &_alloc)
        : timestamp(0), t_sec(0.0), delt_sec(0.0), delx_rps(0.0), dely_rps(0.0), qual(0.0), gx_rps(0.0), gy_rps(0.0), gz_rps(0.0), ax_mps2(0.0), ay_mps2(0.0), az_mps2(0.0), h_mtr(0.0), mx_gauss(0.0), my_gauss(0.0), mz_gauss(0.0), rsv0(0.0), rsv1(0.0), rsv2(0.0), rsv3(0.0)
    {
      (void)_alloc;
    }

    typedef uint64_t _timestamp_type;
    _timestamp_type timestamp;

    typedef double _t_sec_type;
    _t_sec_type t_sec;

    typedef float _delt_sec_type;
    _delt_sec_type delt_sec;

    typedef float _delx_rps_type;
    _delx_rps_type delx_rps;

    typedef float _dely_rps_type;
    _dely_rps_type dely_rps;

    typedef float _qual_type;
    _qual_type qual;

    typedef float _gx_rps_type;
    _gx_rps_type gx_rps;

    typedef float _gy_rps_type;
    _gy_rps_type gy_rps;

    typedef float _gz_rps_type;
    _gz_rps_type gz_rps;

    typedef float _ax_mps2_type;
    _ax_mps2_type ax_mps2;

    typedef float _ay_mps2_type;
    _ay_mps2_type ay_mps2;

    typedef float _az_mps2_type;
    _az_mps2_type az_mps2;

    typedef float _h_mtr_type;
    _h_mtr_type h_mtr;

    typedef float _mx_gauss_type;
    _mx_gauss_type mx_gauss;

    typedef float _my_gauss_type;
    _my_gauss_type my_gauss;

    typedef float _mz_gauss_type;
    _mz_gauss_type mz_gauss;

    typedef float _rsv0_type;
    _rsv0_type rsv0;

    typedef float _rsv1_type;
    _rsv1_type rsv1;

    typedef float _rsv2_type;
    _rsv2_type rsv2;

    typedef float _rsv3_type;
    _rsv3_type rsv3;

    typedef boost::shared_ptr<::kari_estimator::kari_integrated_<ContainerAllocator>> Ptr;
    typedef boost::shared_ptr<::kari_estimator::kari_integrated_<ContainerAllocator> const> ConstPtr;

  }; // struct kari_integrated_

  typedef ::kari_estimator::kari_integrated_<std::allocator<void>> kari_integrated;

  typedef boost::shared_ptr<::kari_estimator::kari_integrated> kari_integratedPtr;
  typedef boost::shared_ptr<::kari_estimator::kari_integrated const> kari_integratedConstPtr;

  // constants requiring out of line definition

  template <typename ContainerAllocator>
  std::ostream &operator<<(std::ostream &s, const ::kari_estimator::kari_integrated_<ContainerAllocator> &v)
  {
    ros::message_operations::Printer<::kari_estimator::kari_integrated_<ContainerAllocator>>::stream(s, "", v);
    return s;
  }

  template <typename ContainerAllocator1, typename ContainerAllocator2>
  bool operator==(const ::kari_estimator::kari_integrated_<ContainerAllocator1> &lhs, const ::kari_estimator::kari_integrated_<ContainerAllocator2> &rhs)
  {
    return lhs.timestamp == rhs.timestamp &&
           lhs.t_sec == rhs.t_sec &&
           lhs.delt_sec == rhs.delt_sec &&
           lhs.delx_rps == rhs.delx_rps &&
           lhs.dely_rps == rhs.dely_rps &&
           lhs.qual == rhs.qual &&
           lhs.gx_rps == rhs.gx_rps &&
           lhs.gy_rps == rhs.gy_rps &&
           lhs.gz_rps == rhs.gz_rps &&
           lhs.ax_mps2 == rhs.ax_mps2 &&
           lhs.ay_mps2 == rhs.ay_mps2 &&
           lhs.az_mps2 == rhs.az_mps2 &&
           lhs.h_mtr == rhs.h_mtr &&
           lhs.mx_gauss == rhs.mx_gauss &&
           lhs.my_gauss == rhs.my_gauss &&
           lhs.mz_gauss == rhs.mz_gauss &&
           lhs.rsv0 == rhs.rsv0 &&
           lhs.rsv1 == rhs.rsv1 &&
           lhs.rsv2 == rhs.rsv2 &&
           lhs.rsv3 == rhs.rsv3;
  }

  template <typename ContainerAllocator1, typename ContainerAllocator2>
  bool operator!=(const ::kari_estimator::kari_integrated_<ContainerAllocator1> &lhs, const ::kari_estimator::kari_integrated_<ContainerAllocator2> &rhs)
  {
    return !(lhs == rhs);
  }

} // namespace kari_estimator

namespace ros
{
  namespace message_traits
  {

    template <class ContainerAllocator>
    struct IsMessage<::kari_estimator::kari_integrated_<ContainerAllocator>>
        : TrueType
    {
    };

    template <class ContainerAllocator>
    struct IsMessage<::kari_estimator::kari_integrated_<ContainerAllocator> const>
        : TrueType
    {
    };

    template <class ContainerAllocator>
    struct IsFixedSize<::kari_estimator::kari_integrated_<ContainerAllocator>>
        : TrueType
    {
    };

    template <class ContainerAllocator>
    struct IsFixedSize<::kari_estimator::kari_integrated_<ContainerAllocator> const>
        : TrueType
    {
    };

    template <class ContainerAllocator>
    struct HasHeader<::kari_estimator::kari_integrated_<ContainerAllocator>>
        : FalseType
    {
    };

    template <class ContainerAllocator>
    struct HasHeader<::kari_estimator::kari_integrated_<ContainerAllocator> const>
        : FalseType
    {
    };

    template <class ContainerAllocator>
    struct MD5Sum<::kari_estimator::kari_integrated_<ContainerAllocator>>
    {
      static const char *value()
      {
        return "2ee82cbaaa93bc22a21da5b4a558e6ab";
      }

      static const char *value(const ::kari_estimator::kari_integrated_<ContainerAllocator> &) { return value(); }
      static const uint64_t static_value1 = 0x2ee82cbaaa93bc22ULL;
      static const uint64_t static_value2 = 0xa21da5b4a558e6abULL;
    };

    template <class ContainerAllocator>
    struct DataType<::kari_estimator::kari_integrated_<ContainerAllocator>>
    {
      static const char *value()
      {
        return "kari_estimator/kari_integrated";
      }

      static const char *value(const ::kari_estimator::kari_integrated_<ContainerAllocator> &) { return value(); }
    };

    template <class ContainerAllocator>
    struct Definition<::kari_estimator::kari_integrated_<ContainerAllocator>>
    {
      static const char *value()
      {
        return "uint64 timestamp\n"
               "float64 t_sec\n"
               "\n"
               "float32 delt_sec\n"
               "\n"
               "float32 delx_rps\n"
               "float32 dely_rps\n"
               "float32 qual\n"
               "\n"
               "float32 gx_rps\n"
               "float32 gy_rps\n"
               "float32 gz_rps\n"
               "\n"
               "float32 ax_mps2\n"
               "float32 ay_mps2\n"
               "float32 az_mps2\n"
               "\n"
               "float32 h_mtr\n"
               "\n"
               "float32 mx_gauss\n"
               "float32 my_gauss\n"
               "float32 mz_gauss\n"
               "\n"
               "float32 rsv0\n"
               "float32 rsv1\n"
               "float32 rsv2\n"
               "float32 rsv3\n";
      }

      static const char *value(const ::kari_estimator::kari_integrated_<ContainerAllocator> &) { return value(); }
    };

  } // namespace message_traits
} // namespace ros

namespace ros
{
  namespace serialization
  {

    template <class ContainerAllocator>
    struct Serializer<::kari_estimator::kari_integrated_<ContainerAllocator>>
    {
      template <typename Stream, typename T>
      inline static void allInOne(Stream &stream, T m)
      {
        stream.next(m.timestamp);
        stream.next(m.t_sec);
        stream.next(m.delt_sec);
        stream.next(m.delx_rps);
        stream.next(m.dely_rps);
        stream.next(m.qual);
        stream.next(m.gx_rps);
        stream.next(m.gy_rps);
        stream.next(m.gz_rps);
        stream.next(m.ax_mps2);
        stream.next(m.ay_mps2);
        stream.next(m.az_mps2);
        stream.next(m.h_mtr);
        stream.next(m.mx_gauss);
        stream.next(m.my_gauss);
        stream.next(m.mz_gauss);
        stream.next(m.rsv0);
        stream.next(m.rsv1);
        stream.next(m.rsv2);
        stream.next(m.rsv3);
      }

      ROS_DECLARE_ALLINONE_SERIALIZER
    }; // struct kari_integrated_

  } // namespace serialization
} // namespace ros

namespace ros
{
  namespace message_operations
  {

    template <class ContainerAllocator>
    struct Printer<::kari_estimator::kari_integrated_<ContainerAllocator>>
    {
      template <typename Stream>
      static void stream(Stream &s, const std::string &indent, const ::kari_estimator::kari_integrated_<ContainerAllocator> &v)
      {
        s << indent << "timestamp: ";
        Printer<uint64_t>::stream(s, indent + "  ", v.timestamp);
        s << indent << "t_sec: ";
        Printer<double>::stream(s, indent + "  ", v.t_sec);
        s << indent << "delt_sec: ";
        Printer<float>::stream(s, indent + "  ", v.delt_sec);
        s << indent << "delx_rps: ";
        Printer<float>::stream(s, indent + "  ", v.delx_rps);
        s << indent << "dely_rps: ";
        Printer<float>::stream(s, indent + "  ", v.dely_rps);
        s << indent << "qual: ";
        Printer<float>::stream(s, indent + "  ", v.qual);
        s << indent << "gx_rps: ";
        Printer<float>::stream(s, indent + "  ", v.gx_rps);
        s << indent << "gy_rps: ";
        Printer<float>::stream(s, indent + "  ", v.gy_rps);
        s << indent << "gz_rps: ";
        Printer<float>::stream(s, indent + "  ", v.gz_rps);
        s << indent << "ax_mps2: ";
        Printer<float>::stream(s, indent + "  ", v.ax_mps2);
        s << indent << "ay_mps2: ";
        Printer<float>::stream(s, indent + "  ", v.ay_mps2);
        s << indent << "az_mps2: ";
        Printer<float>::stream(s, indent + "  ", v.az_mps2);
        s << indent << "h_mtr: ";
        Printer<float>::stream(s, indent + "  ", v.h_mtr);
        s << indent << "mx_gauss: ";
        Printer<float>::stream(s, indent + "  ", v.mx_gauss);
        s << indent << "my_gauss: ";
        Printer<float>::stream(s, indent + "  ", v.my_gauss);
        s << indent << "mz_gauss: ";
        Printer<float>::stream(s, indent + "  ", v.mz_gauss);
        s << indent << "rsv0: ";
        Printer<float>::stream(s, indent + "  ", v.rsv0);
        s << indent << "rsv1: ";
        Printer<float>::stream(s, indent + "  ", v.rsv1);
        s << indent << "rsv2: ";
        Printer<float>::stream(s, indent + "  ", v.rsv2);
        s << indent << "rsv3: ";
        Printer<float>::stream(s, indent + "  ", v.rsv3);
      }
    };

  } // namespace message_operations
} // namespace ros

#endif // KARI_ESTIMATOR_MESSAGE_KARI_INTEGRATED_H
